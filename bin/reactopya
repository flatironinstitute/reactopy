#!/usr/bin/env python

import os
from jinja2 import Template
import json
import shutil
import argparse
from reactopya import ShellScript, reactopya_templates_directory
from argparse import RawTextHelpFormatter
import time


def main():

    commands = [
        {
            'name': 'generate',
            'func': _generate,
            'description': 'Generate or regenerate source code'
        },
        {
            'name': 'watch',
            'func': _watch,
            'description': 'Starting watching for source code changes, and regenerate source code with each change.'
        },
        {
            'name': 'install-electron',
            'func': _install_electron,
            'description': 'Install electron (must be called prior to running start-electron-dev)',
        },
        {
            'name': 'start-electron-dev',
            'func': _start_electron_dev,
            'description': 'Start the electron application in development mode (use install-electron first)'
        },
        {
            'name': 'install-jupyter-extension',
            'func': _install_jupyter_extension,
            'description': 'Install the jupyter notebook extension'
        },
        {
            'name': 'list-widgets',
            'func': _list_widgets,
            'description': 'List the widgets in the current project'
        },
        {
            'name': 'init-project',
            'func': _init_project,
            'description': 'Initialize a new reactopya project (this command is work in progress)'
        },
        {
            'name': 'install-server',
            'func': _install_server,
            'description': 'Install gallery server'
        },
        {
            'name': 'start-server',
            'func': _start_server,
            'description': 'Start gallery server'
        }
    ]
    commands_by_name = {}
    for x in commands:
        commands_by_name[x['name']] = x['func']

    command_description = '\n'.join(['{} - {}'.format(x['name'], x['description']) for x in commands])

    parser = argparse.ArgumentParser(
        description = "Reactopya command-line utility", formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', help = 'One of the following:\n\n{}\n'.format(command_description))

    args=parser.parse_args()
    command=args.command

    if command not in commands_by_name.keys():
        raise Exception('Unrecognized command: {}'.format(command))

    if command not in ['init-project']:
        config=_load_config()
        commands_by_name[command](config, args = args)
    else:
        commands_by_name[command](args = args)


def _init_project(args):
    if os.path.exists('reactopya.config.json'):
        raise Exception("File already exists: reactopya.config.json")
    if os.path.exists('widgets'):
        raise Exception("File or folder already exists: widgets")
    project_name=input('Name of project (no spaces): ') or ''
    version=input('Version (e.g., 0.1.0): ') or ''
    description=input('Description: ') or ''
    author=input('Author: ') or ''
    license=input('License (e.g., Apache-2.0): ')
    obj={
        "project_name": project_name,
        "version": version,
        "description": description,
        "author": author,
        "license": license,
        "package_json": {
            "dependencies": {
            }
        },
        "setup_py": {
            "install_requires": [
            ]
        }
    }
    with open('reactopya.config.json', 'w') as f:
        json.dump(obj, f)
    # template_dir =
    # _generate_directory(os.path.join(reactopya_templates_directory(), '_other', 'widgets', ))
    os.mkdir('widgets')


def _list_widgets(config, args):
    for w in config['widgets']:
        print(w['componentName'])


def _install_electron(config, args):
    _generate(config=config, args=args)
    cmd = '''
        #!/bin/bash
        set -ex
        cd generated/{project_name}
        pip install -e .
        yarn install
        yarn install-electron
    '''.format(project_name=config['project_name'])
    shell_cmd = ShellScript(cmd)
    shell_cmd.start()
    retcode = shell_cmd.wait()

    if retcode != 0:
        raise Exception(
            'Shell script exited with non-zero return code: {}'.format(retcode))

    print('You may now run "reactopya start-electron-dev".')


def _start_electron_dev(config, args):
    _generate(config = config, args = args)
    cmd='''
        #!/bin/bash
        set -ex
        cd generated/{project_name}
        yarn electron-dev
    '''.format(project_name = config['project_name'])
    shell_cmd=ShellScript(cmd)
    shell_cmd.start()
    retcode=shell_cmd.wait()

    if retcode != 0:
        raise Exception(
            'Shell script exited with non-zero return code: {}'.format(retcode))


def _install_server(config, args):
    _generate(config=config, args=args)
    cmd = '''
        #!/bin/bash
        set -ex
        cd generated/{project_name}
        pip install -e .
        yarn install
        yarn build
    '''.format(project_name=config['project_name'])
    shell_cmd = ShellScript(cmd)
    shell_cmd.start()
    retcode = shell_cmd.wait()

    if retcode != 0:
        raise Exception(
            'Shell script exited with non-zero return code: {}'.format(retcode))

    print('You may now run "reactopya start-server".')


def _start_server(config, args):
    _generate(config = config, args = args)
    cmd='''
        #!/bin/bash
        set -ex
        cd generated/{project_name}
        yarn start
    '''.format(project_name = config['project_name'])
    shell_cmd=ShellScript(cmd)
    shell_cmd.start()
    retcode=shell_cmd.wait()

    if retcode != 0:
        raise Exception(
            'Shell script exited with non-zero return code: {}'.format(retcode))


def _install_jupyter_extension(config, args):
    _generate(config = config, args = args)
    cmd='''
        #!/bin/bash
        set -ex
        cd generated/{project_name}
        pip install -e .
        yarn install
        cd ../{project_name}_jup
        pip install -e .
        yarn install
        yarn install-extension
    '''.format(project_name = config['project_name'])
    shell_cmd=ShellScript(cmd)
    shell_cmd.start()
    retcode=shell_cmd.wait()

    if retcode != 0:
        raise Exception(
            'Shell script exited with non-zero return code: {}'.format(retcode))

    print('You may now import {}_jup within a jupyter notebook.'.format(
        config['project_name']))


def _generate(config, args):
    (num_processed, num_changed)=_generate_directory(
        reactopya_templates_directory(), 'generated', config=config)
    if num_changed > 0:
        print('{} files processed, {} changed'.format(num_processed, num_changed))


def _watch(config, args):
    while True:
        _generate(config=config, args=args)
        time.sleep(5)


def _load_config():
    with open('reactopya.config.json', 'r') as f:
        config = json.load(f)
    config['widgets'] = _load_widgets_config()
    return config


def _load_widgets_config():
    dirnames = [
        name for name in os.listdir('widgets')
        if os.path.isdir(os.path.join('widgets', name))
    ]
    ret = []
    for dirname in dirnames:
        json_fname = os.path.join('widgets', dirname, dirname+'.json')
        if os.path.exists(json_fname):
            with open(json_fname, 'r') as f:
                widget = json.load(f)
            ret.append(widget)
    return ret


def _generate_directory(template_source_path, dest_path, config, do_render=True):
    num_files_processed = 0
    num_files_changed = 0
    fnames = [
        name for name in os.listdir(template_source_path)
        if os.path.isfile(os.path.join(template_source_path, name))
    ]
    fnames_dst = [_map_file_name(fname, config=config) for fname in fnames]
    dirnames = [
        name for name in os.listdir(template_source_path)
        if os.path.isdir(os.path.join(template_source_path, name))
    ]
    dirnames_dst = [_map_file_name(dirname, config=config)
                    for dirname in dirnames]

    if len(fnames) == 1 and fnames[0] == '.widgets_go_here':
        return _generate_directory('widgets', dest_path, config, do_render=False)

    if not os.path.exists(dest_path):
        os.mkdir(dest_path)

    fnames_existing = [
        name for name in os.listdir(dest_path)
        if os.path.isfile(os.path.join(dest_path, name))
    ]
    dirnames_existing = [
        name for name in os.listdir(dest_path)
        if os.path.isdir(os.path.join(dest_path, name))
    ]

    for fname in fnames_existing:
        if fname not in fnames_dst:
            print('Removing: {}'.format(os.path.join(dest_path, fname)))
            num_files_changed = num_files_changed + 1
            os.remove(os.path.join(dest_path, fname))

    for dirname in dirnames_existing:
        if (dirname not in (dirnames_dst + ['node_modules', 'dist'])) and (not dirname.endswith('.egg-info')):
            print('Removing directory: {}'.format(
                os.path.join(dest_path, dirname)))
            num_files_changed = num_files_changed + 1
            shutil.rmtree(os.path.join(dest_path, dirname))

    for i, fname in enumerate(fnames):
        path_src = os.path.join(template_source_path, fname)
        path_dst = os.path.join(dest_path, fnames_dst[i])
        if _has_binary_extension(path_src):
            data = _read_binary_file(path_src)
            if _write_binary_file_if_changed(path_dst, data):
                num_files_changed = num_files_changed + 1
        else:
            txt = _read_text_file(path_src)
            if do_render:
                txt2 = Template(txt).render(config)
            else:
                txt2 = txt
            num_files_processed = num_files_processed + 1
            if _write_text_file_if_changed(path_dst, txt2):
                num_files_changed = num_files_changed + 1
    for i, dirname in enumerate(dirnames):
        if dirname not in ['node_modules', '.git']:
            nump, numc = _generate_directory(
                os.path.join(template_source_path, dirname),
                os.path.join(dest_path, dirnames_dst[i]),
                config=config,
                do_render=do_render
            )
            num_files_processed = num_files_processed + nump
            num_files_changed = num_files_changed + numc
    return num_files_processed, num_files_changed


def _read_text_file(fname):
    try:
        with open(fname, 'r') as f:
            return f.read()
    except:
        return ''

def _read_binary_file(fname):
    try:
        with open(fname, 'rb') as f:
            return f.read()
    except:
        return ''


def _write_text_file_if_changed(fname, txt):
    if os.path.exists(fname):
        txt_existing = _read_text_file(fname)
    else:
        txt_existing = None
    if txt != txt_existing:
        print('Writing: {}'.format(fname))
        with open(fname, 'w') as f:
            f.write(txt)
        return True
    else:
        # print('Unmodified: {}'.format(fname))
        return False

def _write_binary_file_if_changed(fname, data):
    if os.path.exists(fname):
        data_existing = _read_binary_file(fname)
    else:
        data_existing = None
    if data != data_existing:
        print('Writing: {}'.format(fname))
        with open(fname, 'wb') as f:
            f.write(data)
        return True
    else:
        # print('Unmodified: {}'.format(fname))
        return False


def _map_file_name(fname, config):
    fname = fname.replace('__project_name__', config['project_name'])
    return fname

def _has_binary_extension(path):
    ext = os.path.splitext(path)[1]
    binary_extensions = ['.jpg', '.png', '.gif', '.svg', '.dat', '.mda']
    return (ext in binary_extensions)

if __name__ == '__main__':
    main()
